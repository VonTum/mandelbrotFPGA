


module staticForLoop #(int TO) {

    state int #(FROM: 0, TO) cur_iter
    state bool cur_iter_valid

    action start {
        cur_iter = 0
        cur_iter_valid = true
    }
    trigger iter : int #(FROM: 0, TO) cur
    when cur_iter_valid {
        iter(cur_iter)
        when cur_iter == TO - 1 {
            cur_iter_valid = false
        } else {
            cur_iter = cur_iter + 1
        }
    }
}

module SlowIterator #(T, int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY) {
    domain iter_domain
    LatencyOffsetAction #(OFFSET : -COMPUTATION_LATENCY) next_iter_loop
    CrossDomain iter_is_finised
    CrossAction iter_with_initial_data
    iter_is_finised.in = false
    trigger iter'0 : T data'0 {
        action next_iter'COMPUTATION_LATENCY : T new_data'COMPUTATION_LATENCY {
            next_iter_loop.in(new_data)
        } else {
            iter_is_finised.in = true
        }
    }
    when next_iter_loop.out : T loop_data {
        iter(loop_data)
    }
    when iter_with_initial_data.out : T initial_data_cross {
        iter(initial_data_cross)
    }

    domain request_domain

    bool retry_loop = false
    trigger request_new_data'0 {
        action start_iteration'REQUEST_DATA_LATENCY : T initial_data'REQUEST_DATA_LATENCY {
            iter_with_initial_data.in(initial_data_cross)
        } else {
            retry_loop = true
        }
    }

    state bool last_reset_was_true
    action reset {
        last_reset_was_true = true
    } else {
        // Send down a one-clock pulse on reset release to get request_new_data started
        when last_reset_was_true | iter_is_finised.out | LatencyOffset #(OFFSET: -REQUEST_DATA_LATENCY)(retry_loop) {
            request_new_data()
        }
        last_reset_was_true = false
    }
}



/// new_z = zÂ² + c (z_0 = 0)

/// |z| >= 2
module MandelbrotStep {
    action MandelbrotStep : float z_r, float z_i, float c_r, float c_i -> float new_z_r, float new_z_i, bool is_done {
        float z_sq_r = fp_sub(fp_mul(z_r, z_r), fp_mul(z_i, z_i))
        float z_ri = fp_mul(z_r, z_i)
        float z_sq_i = fp_add(z_ri, z_ri)

        new_z_r = fp_add(z_sq_r, c_r)
        new_z_i = fp_add(z_sq_i, c_i)

        float radius_sq = fp_add(fp_mul(new_z_r, new_z_r), fp_mul(new_z_i, new_z_i))

        float four = fp_fromint(4)
        is_done = fp_gt(radius_sq, four)
    }
}

module MandelbrotSlowIter {
    domain request_domain
    SlowIterator iter

    trigger request_new_point'0

    when iter.request_new_data {
        request_new_point()
    }

    action start_iteration_for_new_point'4 : float x'4, float y'4 {
        float zero = transmute #(T1: type int#(FROM: 0, TO: pow2#(E: 32)))(0)
        float[4] initial_state = [zero, zero, x, y]

        iter.start_iteration(initial_state)
    }

    domain iter_domain
    trigger done
    when iter.iter : float[4] state {
        float z_r = state[0]
        float z_i = state[1]
        float c_r = state[2]
        float c_i = state[3]

        float new_z_r, float new_z_i, bool is_done = MandelbrotStep(z_r, z_i, c_r, c_i)

        when is_done {
            done()
        } else {
            iter.next_iter([new_z_r, new_z_i, c_r, c_i])
        }
    }
}

module tuple2 #(T1, T2) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0 -> bool[SIZE1 + SIZE2] packed_o'0
    packed_o[:SIZE1] = transmute_to_bits(v1_i)
    packed_o[SIZE1:] = transmute_to_bits(v2_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2] packed_i'0 -> T1 v1_o'0, T2 v2_o'0
    v1_o = transmute_from_bits(packed_i[:SIZE1])
    v2_o = transmute_from_bits(packed_i[SIZE1:])
}

module tuple3 #(T1, T2, T3) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    gen int SIZE3 = sizeof#(T: type T3)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0, T3 v3_i'0 -> bool[SIZE1 + SIZE2 + SIZE3] packed_o'0
    packed_o[:SIZE1] = transmute_to_bits(v1_i)
    packed_o[SIZE1:SIZE1+SIZE2] = transmute_to_bits(v2_i)
    packed_o[SIZE1+SIZE2:] = transmute_to_bits(v3_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2 + SIZE3] packed_i'0 -> T1 v1_o'0, T2 v2_o'0, T3 v3_o'0
    v1_o = transmute_from_bits(packed_i[:SIZE1])
    v2_o = transmute_from_bits(packed_i[SIZE1:SIZE1+SIZE2])
    v3_o = transmute_from_bits(packed_i[SIZE1+SIZE2:])
}

module SlowIterator2 #(InitialT, ResultT, ExtraDataT, int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY) {
    domain clk

    CrossActionNoData rst_act
    action rst {
        rst_act.in()
    }

    domain iter_domain
    CrossAction iter_is_finished
    CrossAction iter_with_initial_data

    bool iter_continue = false
    trigger iter'0 : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out'0 {
        action done'COMPUTATION_LATENCY: ResultT result'COMPUTATION_LATENCY {
            iter_is_finished.in(result)
        } else {
            iter_continue = true
        }
    }
    trigger is_initial'0: InitialT initial_data'0

    when LatencyOffset #(OFFSET: -COMPUTATION_LATENCY)(iter_continue) {
        iter(0)
    }
    when iter_with_initial_data.out : InitialT initial_data_cross {
        iter(0)
        is_initial(initial_data_cross)
    }

    domain request_domain
    state ExtraDataT extra_data_stored
    bool retry_loop = false

    trigger may_start'0 {
        action start'REQUEST_DATA_LATENCY : InitialT initial_data'REQUEST_DATA_LATENCY, ExtraDataT extra_data'REQUEST_DATA_LATENCY {
            iter_with_initial_data.in(initial_data)
            extra_data_stored = extra_data
        } else {
            retry_loop = true
        }
    }

    trigger finish'0 : ResultT result_data'0, ExtraDataT extra_result_data'REQUEST_DATA_LATENCY

    state bool last_reset_was_true
    bool retry_loop_done = LatencyOffset #(OFFSET: -REQUEST_DATA_LATENCY)(retry_loop)

    when rst_act.out {
        last_reset_was_true = true
    } else {
        // Send down a one-clock pulse on reset release to get request_new_data started
        when last_reset_was_true | retry_loop_done {
            may_start()
        }
        when iter_is_finished.out : ResultT result_data {
            may_start()
            finish(result_data, extra_data_stored)
        }
        last_reset_was_true = false
    }
}

module SlowIteratorWithOutputFIFO #(InitialT, ResultT, ExtraDataT, int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY, int MAX_ITERATIONS) {
    domain clk

    SlowIterator2 parent
    action rst {
        parent.rst()
    }

    domain iter_domain
    trigger iter'0 : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out'0 {
        action done'COMPUTATION_LATENCY: ResultT result'COMPUTATION_LATENCY {
            parent.done(result)
        }
    }
    when parent.iter : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out {
        iter(iter_sentinel_out)
    }
    trigger is_initial'0: InitialT initial_data'0
    when parent.is_initial: InitialT initial_data {
        is_initial(initial_data)
    }

    domain request_domain
    trigger may_start'0 {
        action start'REQUEST_DATA_LATENCY : InitialT initial_data'REQUEST_DATA_LATENCY, ExtraDataT extra_data'REQUEST_DATA_LATENCY {
            parent.start(initial_data, extra_data)
        }
    }
    when parent.may_start {
        may_start()
    }

    trigger finish : ResultT result_data, ExtraDataT extra_result_data
    when parent.finish : ResultT result_data, ExtraDataT extra_result_data {
        finish(result_data, extra_result_data)
    }
}


module SlowIteratorState #(T, int MAX_LATENCY, int LATENCY) {
    assert #(C: LATENCY <= MAX_LATENCY)
    assert #(C: LATENCY >= 0)

    state T iter_state
    T iter_stack_backwards = LatencyOffset #(OFFSET: -LATENCY)(iter_state)

    action link'0 : int#(FROM: 0, TO: MAX_LATENCY) _sentinel'0 {
        output T old'0
        input T new'LATENCY

        action init'0 : T initial_data'0 {
            old = initial_data
        } else {
            old = iter_stack_backwards
        }

        iter_state = new
    }
}

module MandelbrotSlowIter2 #(ExtraDataT, int INPUT_DATA_LATENCY) {
    gen int MAX_ITERATION = 100

    SlowIterator2 #(COMPUTATION_LATENCY: 55, REQUEST_DATA_LATENCY: 22) iter

    domain clk
    action rst'0 {
        iter.rst()
    }
    
    trigger may_start'-INPUT_DATA_LATENCY
    when iter.may_start {
        may_start()
    }
    action start'0 : float r'0, float i'0, ExtraDataT extra_data'0 {
        iter.start([r, i], extra_data)
    }

    trigger finish'0: int iteration_count'0, ExtraDataT extra_data'0
    when iter.finish: int iteration_count, ExtraDataT extra_data {
        finish(iteration_count, extra_data)
    }

    SlowIteratorState #(T: type float) z_r
    SlowIteratorState #(T: type float) z_i
    SlowIteratorState #(T: type float) c_r
    SlowIteratorState #(T: type float) c_i
    SlowIteratorState #(T: type int #(FROM: 0, TO: MAX_ITERATION)) iteration
    
    float zero = fp_fromint(0)
    when iter.iter : int sentinel {
        z_r.link(sentinel)
        z_i.link(sentinel)
        c_r.link(sentinel)
        c_i.link(sentinel)
        iteration.link(sentinel)
        
        when iter.is_initial : float[2] init_data {
            z_r.init(zero)
            z_i.init(zero)
            c_r.init(init_data[0])
            c_i.init(init_data[1])
            iteration.init(0)
        }

        z_r.new, z_i.new, bool is_done = MandelbrotStep(z_r.old, z_i.old, c_r.old, c_i.old)
        c_r.new = c_r.old
        c_i.new = c_i.old
        iteration.new = unsafe_int_cast#(FROM: 0, TO: MAX_ITERATION)(iteration.old + 1)

        when is_done {
            iter.done(iteration.old)
        } else when iteration.old == MAX_ITERATION - 1 {
            iter.done(MAX_ITERATION)
        }
    }
}

module ScreenIterator #(int WIDTH, int HEIGHT) {
    state int #(FROM: 0, TO: WIDTH) cur_x
    state int #(FROM: 0, TO: HEIGHT) cur_y
    output state bool may_next
    
    action start {
        cur_x = 0
        cur_y = 0
        may_next = true
    }

    bool x_at_end = cur_x == WIDTH - 1
    bool y_at_end = cur_y == HEIGHT - 1

    output bool last = false
    
    output bool may_start = !may_next
    action next : -> int #(FROM: 0, TO: WIDTH) x, int #(FROM: 0, TO: HEIGHT) y {
        x = cur_x
        y = cur_y

        when x_at_end {
            cur_x = 0
            when y_at_end {
                last = true
            } else {
                cur_y = unsafe_int_cast#(FROM: 0, TO: HEIGHT) (cur_y + 1)
            }
        } else {
            cur_x = unsafe_int_cast#(FROM: 0, TO: WIDTH) (cur_x + 1)
        }

        may_next = !x_at_end | !y_at_end
    }
    
    action rst {
        cur_x = WIDTH - 1
        cur_y = HEIGHT - 1
        may_next = false
    }
}

module PixelToComplex #(int WIDTH, int HEIGHT) {
    action PixelToComplex : 
        float origin_r,
        float origin_i,
        float step,
        int#(FROM: 0, TO: WIDTH) px_x,
        int#(FROM: 0, TO: HEIGHT) px_y -> float r, float i {
        r = fp_fmadd(step, fp_fromint(px_x - WIDTH / 2), origin_r)
        i = fp_fmadd(step, fp_fromint(px_y - HEIGHT / 2), origin_i)
    }
}

module WholeMandelbrotComputer {
    gen int WIDTH = 64
    gen int HEIGHT = 64
    
    ScreenIterator #(WIDTH, HEIGHT) pixel_producer
    SameCycleReadFIFO #(DEPTH: 64, EXTRA_IN_FLIGHT: 2) outputFIFO
    MandelbrotSlowIter2 mandel_iter
    
    action rst'0 {
        pixel_producer.rst()
        mandel_iter.rst()
        outputFIFO.rst()
    }


    input float origin_r_st
    input float origin_i_st
    input float scale_st

    output bool may_start = pixel_producer.may_start
    action start {
        pixel_producer.start()
    }
    
    tuple3 mandel_iter_extra_data
    when pixel_producer.may_next & outputFIFO.may_push {
        when mandel_iter.may_start {
            int x, int y = pixel_producer.next()

            float r, float i = PixelToComplex(origin_r_st, origin_i_st, scale_st, x, y)

            mandel_iter.start(r, i, mandel_iter_extra_data.pack(x, y, pixel_producer.last))
        }
    }

    tuple2 data
    trigger may_read_px'0 {
        action read_px'0 : -> int#(FROM: 0, TO: pow2#(E:16)) iter_count'0, int#(FROM: 0, TO: pow2#(E: 32)) addr'0, bool done'0 {
            iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT) + 1] extra_data = data.unpack(outputFIFO.pop())
            int x, int y, done = mandel_iter_extra_data.unpack(extra_data)
            addr = y * WIDTH + x
        }
    }
    when outputFIFO.may_pop {
        may_read_px()
    }

    when mandel_iter.finish : int iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT) + 1] extra_data {
        outputFIFO.push(data.pack(iter_count, extra_data))
    }
}

module WholeMandelbrotComputerDummy {
    action rst'0 {
    }

    input float origin_r_st'0
    input float origin_i_st'0
    input float scale_st'0

    state bool running'0
    initial running = false

    state int#(FROM: 0, TO: pow2#(E:32)) addr'0
    state int#(FROM: 0, TO: pow2#(E:16)) data'0
    state int#(FROM: 0, TO: pow2#(E:4)) wait'0
    initial addr = 0
    initial data = 0
    initial wait = 0

    output bool may_start = !running
    action start'0 {
        running = true
        wait = 1
    }

    trigger may_read_px'0 {
        action read_px'0 : -> int#(FROM: 0, TO: pow2#(E:16)) _data'0, int#(FROM: 0, TO: pow2#(E: 32)) _addr'0, bool _done'0 {
            _addr = addr
            _data = data
            _done = addr == 100
            data = unsafe_int_cast#(FROM: 0, TO: pow2#(E:16))(data + 2)
            addr = unsafe_int_cast#(FROM: 0, TO: pow2#(E:32))(addr + 1)
            when addr != 100 {
                wait = 1
            }
        }
    }
    when wait != 0 {
        wait = unsafe_int_cast#(FROM: 0, TO: pow2#(E:4))(wait + 1)
    } else {
        may_read_px()
    }
}

module TapascoTop {
    gen int NUM_REGS = 3
    gen int ADDR_WIDTH = 32
    gen int DATA_WIDTH = 32
    
    WholeMandelbrotComputerDummy acc
    Axi4LiteSlave slave

    //domain clk
    input bool nreset'0
    when !nreset {
        acc.rst()
    }
    trigger intr'0

    //output bool ctrl_arready'0 = slave.arready
    output bool ctrl_arready'0 = slave.arready
    input bool ctrl_arvalid'0
    slave.arvalid = ctrl_arvalid
    input int #(FROM: 0, TO: pow2#(E: 32)) ctrl_araddr'0
    slave.araddr = ctrl_araddr
    input bool [3] ctrl_arprot'0
    slave.arprot = ctrl_arprot

    input bool ctrl_rready
    slave.rready = ctrl_rready
    output bool ctrl_rvalid = slave.rvalid
    output bool[32] ctrl_rdata = slave.rdata
    output bool[2] ctrl_rresp = slave.rresp
    output bool ctrl_awready = slave.awready
    input bool ctrl_awvalid
    slave.awvalid = ctrl_awvalid
    input int #(FROM: 0, TO: pow2#(E: 32)) ctrl_awaddr
    slave.awaddr = ctrl_awaddr
    input bool[2] ctrl_awprot
    slave.awprot = ctrl_awprot
    output bool ctrl_wready = slave.wready
    input bool ctrl_wvalid
    slave.wvalid = ctrl_wvalid
    input bool[32] ctrl_wdata
    slave.wdata = ctrl_wdata
    input bool[4] ctrl_wstrb
    slave.wstrb = ctrl_wstrb
    input bool ctrl_bready
    slave.bready = ctrl_bready
    output bool ctrl_bvalid = slave.bvalid
    output bool[2] ctrl_bresp = slave.bresp


    state bool [32] register0
    state bool [32] register1
    state bool [32] register2

    //domain aw_domain
    Axi4Master #(ADDR_WIDTH, DATA_WIDTH) mem
    input bool mem_awready
    mem.awready = mem_awready
    output bool mem_awvalid = mem.awvalid
    output int #(FROM: 0, TO: pow2#(E: ADDR_WIDTH)) mem_awaddr = mem.awaddr
    output bool [8] mem_awlen = mem.awlen
    output bool [3] mem_awsize = mem.awsize
    output bool [2] mem_awburst = mem.awburst
    output bool mem_awlock = mem.awlock
    output bool [4] mem_awcache = mem.awcache
    output bool [3] mem_awprot = mem.awprot
    output bool [4] mem_awqos = mem.awqos
    output bool [4] mem_awregion = mem.awregion
    //output bool [USER_WIDTH] awuser
    //output bool [ID_WIDTH] awid

    //domain w_domain
    input bool mem_wready
    mem.wready = mem_wready
    output bool mem_wvalid = mem.wvalid
    output bool [DATA_WIDTH] mem_wdata = mem.wdata
    output bool [DATA_WIDTH/8] mem_wstrb = mem.wstrb
    output bool mem_wlast = mem.wlast

    //domain b_domain
    output bool mem_bready'0 = mem.bready
    input bool mem_bvalid'0
    mem.bvalid = mem_bvalid
    input bool [2] mem_bresp'0
    mem.bresp = mem_bresp


    // User code

    // Accessing ports
    state bool [32] return_value
    state bool return_valid

    initial return_valid = false
    when !nreset {
        return_valid = false
    }

    when !return_valid {
        slave.read_request()
    }
    when return_valid {
        slave.read_response(return_value)
        when slave.read_response_fire {
            return_valid = false
        }
    }
    when slave.read_request_fire : int _addr {
        when _addr == 0 {
            return_value = Repeat(false)
        } else when _addr == 16 {
            return_value = Repeat(false)
        } else when _addr == 32 {
            return_value = register0
        } else when _addr == 48 {
            return_value = register1
        } else {
            return_value = register2
        }
        return_valid = true
    }

    state int write_addr
    state bool write_addr_valid
    state bool write_resp_valid

    slave.write_addr_request()
    when slave.write_addr_request_fire : int _addr {
        write_addr = _addr / 16
        write_addr_valid = true
    }

    when write_addr_valid & !write_resp_valid {
        slave.write_data_request()
        when slave.write_data_request_fire : bool [32] _data, bool[4] _strb {
            when write_addr == 0 {
                when _data[0] {
                    acc.start()
                }
            } else {
                bool[32] tmp = register0
                when write_addr == 48 {
                    tmp = register1
                } else when write_addr == 64 {
                    tmp = register2
                }

                for int i in 0..4 {
                    when _strb[i] {
                        tmp[i*8+:8] = _data[i*8+:8]
                    }
                }

                when write_addr == 32 {
                    register0 = tmp
                } else when write_addr == 48 {
                    register1 = tmp
                } else when write_addr == 64 {
                    register2 = tmp
                }
            }

            write_addr_valid = false
            write_resp_valid = true
        }
    }

    when write_resp_valid {
        slave.write_response()
        when slave.write_response_fire {
            write_resp_valid = false
        }
    }

    acc.origin_r_st = transmute_from_bits(register0)
    acc.origin_i_st = transmute_from_bits(register1)
    acc.scale_st = transmute_from_bits(register2)

    // Memory Access
    state int mem_addr 
    state bool[DATA_WIDTH] mem_data 
    state bool mem_addr_valid
    state bool mem_data_valid
    initial mem_addr_valid = false
    initial mem_data_valid = false

    when !mem_data_valid & !mem_addr_valid {
        when acc.may_read_px {
            int addr, int data, bool done = acc.read_px()
            mem_data = transmute_to_bits(data)
            mem_addr = addr
            mem_addr_valid = true
            mem_data_valid = true
            when done {
                intr()
            }
        }
    }
    
    when mem_addr_valid {
        mem.write_addr_request(mem_addr * 4)
        when mem.write_addr_request_fire {
            mem_addr_valid = false
        }
    }

    when mem_data_valid {
        mem.write_data_request(mem_data)
        when mem.write_data_request_fire {
            mem_data_valid = false
        }
    }

    mem.write_response()
    when mem.write_response_fire {}

}
