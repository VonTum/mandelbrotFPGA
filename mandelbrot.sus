
module tuple2 #(T1, T2) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0 -> bool[SIZE1 + SIZE2] packed_o'0
    packed_o[:SIZE1] = transmute_to_bits(v1_i)
    packed_o[SIZE1:] = transmute_to_bits(v2_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2] packed_i'0 -> T1 v1_o'0, T2 v2_o'0
    v1_o = transmute_from_bits(packed_i[:SIZE1])
    v2_o = transmute_from_bits(packed_i[SIZE1:])
}

module tuple3 #(T1, T2, T3) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    gen int SIZE3 = sizeof#(T: type T3)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0, T3 v3_i'0 -> bool[SIZE1 + SIZE2 + SIZE3] packed_o'0
    packed_o[:SIZE1] = transmute_to_bits(v1_i)
    packed_o[SIZE1:SIZE1+SIZE2] = transmute_to_bits(v2_i)
    packed_o[SIZE1+SIZE2:] = transmute_to_bits(v3_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2 + SIZE3] packed_i'0 -> T1 v1_o'0, T2 v2_o'0, T3 v3_o'0
    v1_o = transmute_from_bits(packed_i[:SIZE1])
    v2_o = transmute_from_bits(packed_i[SIZE1:SIZE1+SIZE2])
    v3_o = transmute_from_bits(packed_i[SIZE1+SIZE2:])
}



/// new_z = zÂ² + c (z_0 = 0)

/// |z| >= 2
module MandelbrotStep {
    interface MandelbrotStep : 
        float z_r, float z_i, float c_r, float c_i -> 
        float new_z_r, float new_z_i, bool is_done

    float z_sq_r = fp_sub(fp_mul(z_r, z_r), fp_mul(z_i, z_i))
    float z_ri = fp_mul(z_r, z_i)
    float z_sq_i = fp_add(z_ri, z_ri)

    new_z_r = fp_add(z_sq_r, c_r)
    new_z_i = fp_add(z_sq_i, c_i)

    float magnitude_sq = fp_add(fp_mul(new_z_r, new_z_r), fp_mul(new_z_i, new_z_i))

    float four = fp_fromint(4)
    is_done = fp_gt(magnitude_sq, four)
}

module SlowIterator2 #(InitialT, ResultT, ExtraDataT, int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY) {
    domain clk

    CrossActionNoData rst_act
    action rst {
        rst_act.in()
    }

    domain iter_domain
    CrossAction iter_is_finished
    CrossAction iter_with_initial_data

    bool iter_continue = false
    trigger iter'0 : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out'0 {
        action done'COMPUTATION_LATENCY: ResultT result'COMPUTATION_LATENCY {
            iter_is_finished.in(result)
        } else {
            iter_continue = true
        }
    }
    trigger is_initial'0: InitialT initial_data'0

    when LatencyOffset #(OFFSET: -COMPUTATION_LATENCY)(iter_continue) {
        iter(0)
    }
    when iter_with_initial_data.out : InitialT initial_data_cross {
        iter(0)
        is_initial(initial_data_cross)
    }

    domain request_domain
    state ExtraDataT extra_data_stored
    bool retry_loop = false

    trigger may_start'0 {
        action start'REQUEST_DATA_LATENCY : InitialT initial_data_start'REQUEST_DATA_LATENCY, ExtraDataT extra_data'REQUEST_DATA_LATENCY {
            iter_with_initial_data.in(initial_data_start)
            extra_data_stored = extra_data
        } else {
            retry_loop = true
        }
    }

    trigger finish'0 : ResultT result_data'0, ExtraDataT extra_result_data'REQUEST_DATA_LATENCY

    state bool last_reset_was_true
    bool retry_loop_done = LatencyOffset #(OFFSET: -REQUEST_DATA_LATENCY)(retry_loop)

    when rst_act.out {
        last_reset_was_true = true
    } else {
        // Send down a one-clock pulse on reset release to get request_new_data started
        when last_reset_was_true | retry_loop_done {
            may_start()
        }
        when iter_is_finished.out : ResultT result_data {
            may_start()
            finish(result_data, extra_data_stored)
        }
        last_reset_was_true = false
    }
}

module SlowIteratorWithOutputFIFO #(InitialT, ResultT, ExtraDataT, int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY) {
    domain clk

    SlowIterator2 parent
    action rst {
        parent.rst()
    }

    domain iter_domain
    trigger iter'0 : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out'0 {
        action done'COMPUTATION_LATENCY: ResultT result'COMPUTATION_LATENCY {
            parent.done(result)
        }
    }
    when parent.iter : int #(FROM: 0, TO: noinfer#(V: COMPUTATION_LATENCY+1)) iter_sentinel_out {
        iter(iter_sentinel_out)
    }
    trigger is_initial'0: InitialT initial_data'0
    when parent.is_initial: InitialT initial_data {
        is_initial(initial_data)
    }

    domain request_domain
    trigger may_start'0 {
        action start'REQUEST_DATA_LATENCY : InitialT initial_data_i'REQUEST_DATA_LATENCY, ExtraDataT extra_data'REQUEST_DATA_LATENCY {
            parent.start(initial_data_i, extra_data)
        }
    }
    when parent.may_start {
        may_start()
    }

    trigger finish : ResultT result_data, ExtraDataT extra_result_data
    when parent.finish : ResultT result_data, ExtraDataT extra_result_data {
        finish(result_data, extra_result_data)
    }
}


module SlowIteratorState #(T, int MAX_LATENCY, int LATENCY) {
    assert #(C: LATENCY <= MAX_LATENCY)
    assert #(C: LATENCY >= 0)

    state T iter_state
    T iter_stack_backwards = LatencyOffset #(OFFSET: -LATENCY)(iter_state)

    action link'0 : int#(FROM: 0, TO: MAX_LATENCY) _sentinel'0 {
        output T old'0
        input T new'LATENCY

        action init'0 : T initial_data'0 {
            old = initial_data
        } else {
            old = iter_stack_backwards
        }

        iter_state = new
    }
}

module MandelbrotSlowIter2 #(ExtraDataT, int INPUT_DATA_LATENCY) {
    gen int MAX_ITERATION = 100

    SlowIterator2 iter

    domain clk
    action rst'0 {
        iter.rst()
    }
    
    trigger may_start'-INPUT_DATA_LATENCY
    when iter.may_start {
        may_start()
    }
    action start'0 : float r'0, float i'0, ExtraDataT extra_data'0 {
        iter.start([r, i], extra_data)
    }

    trigger finish'0: int iteration_count'0, ExtraDataT extra_data_o'0
    when iter.finish: int iteration_count, ExtraDataT extra_data {
        finish(iteration_count, extra_data)
    }

    SlowIteratorState #(T: type float) z_r
    SlowIteratorState #(T: type float) z_i
    SlowIteratorState #(T: type float) c_r
    SlowIteratorState #(T: type float) c_i
    SlowIteratorState #(T: type int #(FROM: 0, TO: MAX_ITERATION)) iteration
    
    float zero = fp_fromint(0)
    when iter.iter : int sentinel {
        z_r.link(sentinel)
        z_i.link(sentinel)
        c_r.link(sentinel)
        c_i.link(sentinel)
        iteration.link(sentinel)
        
        when iter.is_initial : float[2] init_data {
            z_r.init(zero)
            z_i.init(zero)
            c_r.init(init_data[0])
            c_i.init(init_data[1])
            iteration.init(0)
        }

        z_r.new, z_i.new, bool is_done = MandelbrotStep(z_r.old, z_i.old, c_r.old, c_i.old)
        c_r.new = c_r.old
        c_i.new = c_i.old
        iteration.new = unsafe_int_cast#(FROM: 0, TO: MAX_ITERATION)(iteration.old + 1)

        when is_done {
            iter.done(iteration.old)
        } else when iteration.old == MAX_ITERATION - 1 {
            iter.done(MAX_ITERATION)
        }
    }
}


module ScreenIterator #(int WIDTH, int HEIGHT) {
    state int #(FROM: 0, TO: WIDTH) cur_x
    state int #(FROM: 0, TO: HEIGHT) cur_y
    
    output state bool may_next
    action next : -> int #(FROM: 0, TO: WIDTH) x, int #(FROM: 0, TO: HEIGHT) y {
        x = cur_x
        y = cur_y

        when cur_x == WIDTH - 1 {
            when cur_y == HEIGHT - 1 {
                may_next = false
            }
            cur_y = (cur_y + 1) % HEIGHT
        }
        cur_x = (cur_x + 1) % WIDTH
    }

    output bool may_start = !may_next
    action start {
        cur_x = 0
        cur_y = 0
        may_next = true
    }
    
    action rst {
        may_next = false
    }
}

module PixelToComplex #(int WIDTH, int HEIGHT) {
    interface PixelToComplex : 
        float origin_r,
        float origin_i,
        float step,
        int#(FROM: 0, TO: WIDTH) px_x,
        int#(FROM: 0, TO: HEIGHT) px_y -> float r, float i

    int x = px_x - WIDTH / 2
    int y = px_y - HEIGHT / 2
    r = fp_fmadd(step, fp_fromint(x), origin_r)
    i = fp_fmadd(step, fp_fromint(y), origin_i)
}

module WholeMandelbrotComputer#(int WIDTH, int HEIGHT) {
    ScreenIterator #(WIDTH, HEIGHT) pixel_producer
    SameCycleReadFIFO #(DEPTH: 64, EXTRA_IN_FLIGHT: 2) outputFIFO
    MandelbrotSlowIter2 while_loop
    
    action rst'0 {
        pixel_producer.rst()
        while_loop.rst()
        outputFIFO.rst()
    }


    input float origin_r
    input float origin_i
    input float step

    output bool may_start = pixel_producer.may_start
    action start {
        pixel_producer.start()
    }
    
    tuple2 while_loop_extra_data
    when pixel_producer.may_next & outputFIFO.may_push {
        when while_loop.may_start {
            int x, int y = pixel_producer.next()

            float r, float i = PixelToComplex(origin_r, origin_i, step, x, y)

            while_loop.start(r, i, while_loop_extra_data.pack(x, y))
        }
    }

    tuple2 data
    trigger may_read_px'0 {
        action read_px'0 : -> int#(FROM: 0, TO: pow2#(E:32)) iter_count'0, int#(FROM: 0, TO: pow2#(E: 32)) addr'0 {
            iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT)] extra_data = data.unpack(outputFIFO.pop())
            int x, int y = while_loop_extra_data.unpack(extra_data)
            addr = y * WIDTH + x
        }
    }
    when outputFIFO.may_pop {
        may_read_px()
    }

    when while_loop.finish : int iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT)] extra_data {
        outputFIFO.push(data.pack(iter_count, extra_data))
    }
}

/// The order in which results arrive is not the same as the order of inputs, due to some taking more cycles to execute. 
module ParallelWhile #(int COMPUTATION_LATENCY, int REQUEST_DATA_LATENCY) {
    domain iter_domain
    gen int TOTAL_CYCLES = COMPUTATION_LATENCY + REQUEST_DATA_LATENCY
    state int#(FROM: 0, TO: TOTAL_CYCLES) cur_iter_st
    initial cur_iter_st = 0

    bool should_continue'COMPUTATION_LATENCY
    bool do_continue'-REQUEST_DATA_LATENCY = LatencyOffset#(OFFSET: -TOTAL_CYCLES)(should_continue)

    // Increment by one every cycle, no matter if we're processing or not
    cur_iter_st = (cur_iter_st + 1) % TOTAL_CYCLES

    trigger iter'0 : int #(FROM: 0, TO: TOTAL_CYCLES) cur_iter'0 {
        action continue'COMPUTATION_LATENCY {
            should_continue = true
        } else {
            should_continue = false
        }
    } else {
        should_continue = false
    }

    trigger may_start'-REQUEST_DATA_LATENCY

    action start'0 {
        iter(cur_iter_st)
    } else when do_continue {
        iter(cur_iter_st)
    }

    when !do_continue {
        may_start()
    }

    domain clk
    CrossActionNoData rst_act
    action rst {
        rst_act.in()
    }
    // Reset, overwrite valid_slots completely
    when rst_act.out {
        should_continue = false
    }
}

module ParallelWhileState #(T, int NUM_PARALLEL_STATES, int LATENCY) {
    assert #(C: LATENCY <= NUM_PARALLEL_STATES)
    assert #(C: LATENCY >= 0)

    RAM #(DEPTH: NUM_PARALLEL_STATES) st

    action link'0 : int#(FROM: 0, TO: NUM_PARALLEL_STATES) cur_iter_id'0 {
        output T old'2

        action init'0 : T initial_data'0 {
            old = initial_data
        } else {
            old = st.read(cur_iter_id)
        }

        input T new'LATENCY
        st.write(cur_iter_id, new)
    }
}

module ParallelWhileStore #(T, int NUM_PARALLEL_STATES) {
    RAM #(DEPTH: NUM_PARALLEL_STATES) st

    action link'0 : int#(FROM: 0, TO: NUM_PARALLEL_STATES) cur_iter_id'0 {
        // By being a few cycles later, we ensure that the initial data is written before we access it
        output T old'3 = st.read(cur_iter_id)

        action init'0 : T initial_data'0 {
            st.write(cur_iter_id, initial_data)
        }
    }
}

module MandelbrotParallelWhile #(ExtraDataT, int INPUT_DATA_LATENCY) {
    gen int MAX_ITERATION = 100

    ParallelWhile iter
    ParallelWhileState #(T: type float) z_r
    ParallelWhileState #(T: type float) z_i
    ParallelWhileStore #(T: type float) c_r
    ParallelWhileStore #(T: type float) c_i
    ParallelWhileState #(T: type int #(FROM: 0, TO: MAX_ITERATION)) iteration
    ParallelWhileStore #(T: type ExtraDataT) extra_data_st
    
    trigger may_start'-INPUT_DATA_LATENCY
    when iter.may_start {
        may_start()
    }
    float zero = fp_fromint(0)
    action start'0 : float r'0, float i'0, ExtraDataT extra_data'0 {
        iter.start()
        z_r.init(zero)
        z_i.init(zero)
        c_r.init(r)
        c_i.init(i)
        iteration.init(0)
        extra_data_st.init(extra_data)
    }
    trigger finish: int iteration_count, ExtraDataT extra_data_o

    when iter.iter : int sentinel {
        z_r.link(sentinel)
        z_i.link(sentinel)
        c_r.link(sentinel)
        c_i.link(sentinel)
        iteration.link(sentinel)
        extra_data_st.link(sentinel)
        
        z_r.new, z_i.new, bool is_done = MandelbrotStep(z_r.old, z_i.old, c_r.old, c_i.old)

        when is_done {
            finish(iteration.old, extra_data_st.old)
        } else when iteration.old == MAX_ITERATION - 1 {
            finish(MAX_ITERATION, extra_data_st.old)
        } else {
            iter.continue()
            iteration.new = unsafe_int_cast#(FROM: 0, TO: MAX_ITERATION)(iteration.old + 1)
        }
    }

    action rst'0 {
        iter.rst()
    }
}

module WholeMandelbrotComputerFast#(int WIDTH, int HEIGHT) {
    ScreenIterator #(WIDTH, HEIGHT) screen_iter
    SameCycleReadFIFO #(DEPTH: 512, EXTRA_IN_FLIGHT: 200) outputFIFO
    MandelbrotParallelWhile while_loop
    action rst'0 {
        screen_iter.rst()
        while_loop.rst()
        outputFIFO.rst()
    }

    input float origin_r
    input float origin_i
    input float step

    output bool may_start = screen_iter.may_start
    action start {
        screen_iter.start()
    }
    
    tuple2 while_loop_extra_data
    when screen_iter.may_next & outputFIFO.may_push {
        when while_loop.may_start {
            int x, int y = screen_iter.next()

            float r, float i = PixelToComplex(origin_r, origin_i, step, x, y)

            while_loop.start(r, i, while_loop_extra_data.pack(x, y))
        }
    }

    tuple2 data
    trigger may_read_px'0 {
        action read_px'0 : -> int#(FROM: 0, TO: pow2#(E:32)) iter_count'0, int#(FROM: 0, TO: pow2#(E: 32)) addr'0 {
            iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT)] extra_data = data.unpack(outputFIFO.pop())
            int x, int y = while_loop_extra_data.unpack(extra_data)
            addr = y * WIDTH + x
        }
    }
    when outputFIFO.may_pop {
        may_read_px()
    }

    when while_loop.finish : int iter_count, bool[clog2#(V: WIDTH) + clog2#(V: HEIGHT)] extra_data {
        outputFIFO.push(data.pack(iter_count, extra_data))
    }
}

module TapascoTop {
    gen int NUM_REGS = 3
    gen int ADDR_WIDTH = 32
    gen int DATA_WIDTH = 32
    
    gen int WIDTH = 64
    gen int HEIGHT = 64
    
    //WholeMandelbrotComputer#(WIDTH, HEIGHT) slow_acc
    WholeMandelbrotComputerFast#(WIDTH, HEIGHT) acc
    Axi4LiteSlave slave

    // unused, even though it should be. Naja
    bool _may_start = acc.may_start

    //domain clk
    input bool resetn'0
    when !resetn {
        acc.rst()
    }
    trigger intr'0

    state int total_pixels_seen

    //output bool ctrl_arready'0 = slave.arready
    output bool ctrl_arready'0 = slave.arready
    input bool ctrl_arvalid'0
    slave.arvalid = ctrl_arvalid
    input int #(FROM: 0, TO: pow2#(E: 32)) ctrl_araddr'0
    slave.araddr = ctrl_araddr
    input bool [3] ctrl_arprot'0
    slave.arprot = ctrl_arprot

    input bool ctrl_rready
    slave.rready = ctrl_rready
    output bool ctrl_rvalid = slave.rvalid
    output bool[32] ctrl_rdata = slave.rdata
    output bool[2] ctrl_rresp = slave.rresp
    output bool ctrl_awready = slave.awready
    input bool ctrl_awvalid
    slave.awvalid = ctrl_awvalid
    input int #(FROM: 0, TO: pow2#(E: 32)) ctrl_awaddr
    slave.awaddr = ctrl_awaddr
    input bool[2] ctrl_awprot
    slave.awprot = ctrl_awprot
    output bool ctrl_wready = slave.wready
    input bool ctrl_wvalid
    slave.wvalid = ctrl_wvalid
    input bool[32] ctrl_wdata
    slave.wdata = ctrl_wdata
    input bool[4] ctrl_wstrb
    slave.wstrb = ctrl_wstrb
    input bool ctrl_bready
    slave.bready = ctrl_bready
    output bool ctrl_bvalid = slave.bvalid
    output bool[2] ctrl_bresp = slave.bresp


    state bool[32][NUM_REGS] registers

    //domain aw_domain
    Axi4Master #(ADDR_WIDTH, DATA_WIDTH) mem
    input bool mem_awready
    mem.awready = mem_awready
    output bool mem_awvalid = mem.awvalid
    output int #(FROM: 0, TO: pow2#(E: ADDR_WIDTH)) mem_awaddr = mem.awaddr
    output bool [8] mem_awlen = mem.awlen
    output bool [3] mem_awsize = mem.awsize
    output bool [2] mem_awburst = mem.awburst
    output bool mem_awlock = mem.awlock
    output bool [4] mem_awcache = mem.awcache
    output bool [3] mem_awprot = mem.awprot
    output bool [4] mem_awqos = mem.awqos
    output bool [4] mem_awregion = mem.awregion
    //output bool [USER_WIDTH] awuser
    //output bool [ID_WIDTH] awid

    //domain w_domain
    input bool mem_wready
    mem.wready = mem_wready
    output bool mem_wvalid = mem.wvalid
    output bool [DATA_WIDTH] mem_wdata = mem.wdata
    output bool [DATA_WIDTH/8] mem_wstrb = mem.wstrb
    output bool mem_wlast = mem.wlast

    //domain b_domain
    output bool mem_bready'0 = mem.bready
    input bool mem_bvalid'0
    mem.bvalid = mem_bvalid
    input bool [2] mem_bresp'0
    mem.bresp = mem_bresp


    // User code

    // Accessing ports
    state bool [32] return_value
    state bool return_valid

    initial return_valid = false
    when !resetn {
        return_valid = false
    }

    when !return_valid {
        slave.read_request()
    }
    when return_valid {
        slave.read_response(return_value)
        when slave.read_response_fire {
            return_valid = false
        }
    }
    when slave.read_request_fire : int rd_addr {
        when rd_addr == 0 {
            return_value = Repeat(false)
        } else when rd_addr == 16 {
            return_value = Repeat(false)
        } else {
            int reg_id = unsafe_int_cast#(FROM: 0, TO: NUM_REGS)((rd_addr - 32) / 16)

            return_value = registers[reg_id]
        }
        return_valid = true
    }

    state int write_addr
    state bool write_addr_valid
    state bool write_resp_valid

    when !resetn {
        write_addr_valid = false
        write_resp_valid = false
    }

    slave.write_addr_request()
    when slave.write_addr_request_fire : int _addr {
        write_addr = _addr
        write_addr_valid = true
    }

    when write_addr_valid & !write_resp_valid {
        slave.write_data_request()
        when slave.write_data_request_fire : bool [32] _data, bool[4] _strb {
            when write_addr == 0 {
                when _data[0] {
                    acc.start()
                    total_pixels_seen = 0
                }
            } else {
                int reg_id = unsafe_int_cast#(FROM: 0, TO: NUM_REGS)((write_addr - 32) / 16)

                for int i in 0..4 {
                    when _strb[i] {
                        registers[reg_id][i*8+:8] = _data[i*8+:8]
                    }
                }
            }

            write_addr_valid = false
            write_resp_valid = true
        }
    }

    when write_resp_valid {
        slave.write_response()
        when slave.write_response_fire {
            write_resp_valid = false
        }
    }

    acc.origin_r = transmute_from_bits(registers[0])
    acc.origin_i = transmute_from_bits(registers[1])
    acc.step = transmute_from_bits(registers[2])

    // Memory Access
    state int mem_addr 
    state bool[DATA_WIDTH] mem_data 
    state bool mem_addr_valid
    state bool mem_data_valid

    initial mem_addr_valid = false
    initial mem_data_valid = false
    when !resetn {
        mem_addr_valid = false
        mem_data_valid = false
    }


    when !mem_data_valid & !mem_addr_valid {
        when acc.may_read_px {
            int data, int addr = acc.read_px()
            mem_data = transmute_to_bits(data)
            mem_addr = addr
            mem_addr_valid = true
            mem_data_valid = true
            when total_pixels_seen == WIDTH * HEIGHT - 1 {
                intr()
            }
            total_pixels_seen = (total_pixels_seen + 1) % (WIDTH * HEIGHT)
        }
    }
    
    when mem_addr_valid {
        mem.write_addr_request(unsafe_int_cast#(FROM: 0, TO: pow2#(E:32)) (mem_addr * 4))
        when mem.write_addr_request_fire {
            mem_addr_valid = false
        }
    }

    when mem_data_valid {
        mem.write_data_request(mem_data)
        when mem.write_data_request_fire {
            mem_data_valid = false
        }
    }

    mem.write_response()
    when mem.write_response_fire {}

}
